/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/taskcollector-Plugin.ts
var import_obsidian4 = require("obsidian");

// src/taskcollector-TaskCollector.ts
var import_obsidian = require("obsidian");
var TaskCollector = class {
  constructor(app) {
    this.app = app;
    this.app = app;
    this.anyListItem = new RegExp(/^([\s>]*- )([^\\[].*)$/);
    this.anyTaskMark = new RegExp(/^([\s>]*- \[)(.)(\] .*)$/);
    this.blockQuote = new RegExp(/^(\s*>[\s>]*)(.*)$/);
    this.blockRef = new RegExp(/^(.*?)( \^[A-Za-z0-9-]+)?$/);
    this.continuation = new RegExp(/^( {2,}|\t)/);
    this.stripTask = new RegExp(/^([\s>]*-) \[.\] (.*)$/);
  }
  updateSettings(settings) {
    this.settings = settings;
    let momentMatchString = null;
    if (settings.appendDateFormat) {
      momentMatchString = settings.appendDateFormat;
      const onlyFormattingTokens = /^(Y|D|M|H|h|m)+$/;
      const formattingTokens = /(\[[^[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      const array = momentMatchString.match(formattingTokens);
      for (let i = 0, length = array.length; i < length; i++) {
        const segment = array[i];
        if (onlyFormattingTokens.test(segment)) {
          array[i] = segment.replace(/YYYY/g, "\\d{4}").replace(/YY/g, "\\d{2}").replace(/DD/g, "\\d{2}").replace(/D/g, "\\d{1,2}").replace(/MMM/g, "[A-Za-z]{3}").replace(/MM/g, "\\d{2}").replace(/M/g, "\\d{1,2}").replace(/HH/g, "\\d{2}").replace(/H/g, "\\d{1,2}").replace(/hh/g, "\\d{2}").replace(/h/g, "\\d{1,2}").replace(/mm/g, "\\d{2}").replace(/m/g, "\\d{1,2}");
        } else if (segment.match(/\[[\s\S]/)) {
          array[i] = this.replaceLiterals(
            segment.replace(/^\[|\]$/g, "")
          );
        } else {
          array[i] = this.replaceLiterals(segment);
        }
      }
      momentMatchString = array.join("");
      momentMatchString = `\\s*${momentMatchString}\\s*`;
    }
    const completedTasks = (this.settings.onlyLowercaseX ? "x" : "xX") + (this.settings.supportCanceledTasks ? "-" : "");
    if (this.settings.incompleteTaskValues.indexOf(" ") < 0) {
      this.settings.incompleteTaskValues = " " + this.settings.incompleteTaskValues;
    }
    const rightClickTaskMenu = this.settings.rightClickComplete || this.settings.rightClickMark || this.settings.rightClickMove || this.settings.rightClickResetTask || this.settings.rightClickResetAll || this.settings.rightClickToggleAll;
    this.initSettings = {
      removeRegExp: this.tryCreateRemoveRegex(
        this.settings.removeExpression
      ),
      resetRegExp: this.tryCreateResetRegex(momentMatchString),
      incompleteTaskRegExp: this.tryCreateIncompleteRegex(
        this.settings.incompleteTaskValues
      ),
      rightClickTaskMenu,
      registerHandlers: rightClickTaskMenu || this.settings.previewOnClick,
      completedTasks,
      completedTaskRegExp: this.tryCreateCompleteRegex(completedTasks)
    };
    console.debug(
      "TC: updated configuration %o, %o",
      this.settings,
      this.initSettings
    );
  }
  tryCreateRemoveRegex(param) {
    return param ? new RegExp(param, "g") : null;
  }
  tryCreateResetRegex(param) {
    return param ? new RegExp(param + "( \\^[A-Za-z0-9-]+)?$") : null;
  }
  tryCreateCompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  tryCreateIncompleteRegex(param) {
    return new RegExp(`^([\\s>]*- \\[)[${param}](\\] .*)$`);
  }
  removeCheckboxFromLine(lineText) {
    return lineText.replace(this.stripTask, "$1 $2");
  }
  completeTaskLine(lineText, mark = "x") {
    console.debug("TC: complete task with %s: %s", mark, lineText);
    let marked = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
    if (this.initSettings.removeRegExp) {
      marked = marked.replace(this.initSettings.removeRegExp, "");
    }
    if (this.settings.appendDateFormat) {
      const strictLineEnding = lineText.endsWith("  ");
      let blockid = "";
      const match = this.blockRef.exec(marked);
      if (match && match[2]) {
        marked = match[1];
        blockid = match[2];
      }
      if (!marked.endsWith(" ")) {
        marked += " ";
      }
      marked += (0, import_obsidian.moment)().format(this.settings.appendDateFormat) + blockid;
      if (strictLineEnding) {
        marked += "  ";
      }
    }
    return marked;
  }
  markAllTasksComplete(source, mark) {
    const lines = source.split("\n");
    const result = [];
    for (const line of lines) {
      if (this.initSettings.incompleteTaskRegExp.exec(line)) {
        result.push(this.completeTaskLine(line, mark));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  markTaskInSource(source, mark, lines = []) {
    const split = source.split("\n");
    for (const n of lines) {
      split[n] = this.markTaskLine(split[n], mark);
    }
    return split.join("\n");
  }
  markTaskLine(lineText, mark) {
    const taskMatch = this.anyTaskMark.exec(lineText);
    if (mark === "Backspace") {
      lineText = this.removeCheckboxFromLine(lineText);
    } else if (taskMatch) {
      const completeMark = this.initSettings.completedTasks.indexOf(mark) >= 0;
      if (this.isCompletedTaskLine(lineText)) {
        if (completeMark) {
          console.log("TC: task already completed: %s", lineText);
        } else {
          lineText = this.resetTaskLine(lineText, mark);
        }
      } else if (this.isIncompleteTaskLine(lineText)) {
        if (completeMark) {
          lineText = this.settings.appendRemoveAllTasks ? this.resetTaskLine(lineText, mark) : this.completeTaskLine(lineText, mark);
        } else {
          lineText = this.resetTaskLine(lineText, mark);
        }
      } else if (mark === " ") {
        lineText = this.resetTaskLine(lineText, mark);
      } else {
        console.log(
          "TC: unknown mark (%s), leaving unchanged: %s",
          mark,
          lineText
        );
      }
    } else if (mark !== "Backspace") {
      const match = this.anyListItem.exec(lineText);
      if (match && match[2]) {
        console.debug("TC: list item, convert to a task %s", lineText);
        lineText = this.markTaskLine(
          `${match[1]}[ ] ${match[2]}`,
          mark
        );
      } else {
        console.debug("TC: not a task or list item %s", lineText);
      }
    }
    return lineText;
  }
  resetTaskLine(lineText, mark = " ") {
    console.debug("TC: reset task with %s: %s", mark, lineText);
    lineText = lineText.replace(this.anyTaskMark, `$1${mark}$3`);
    const strictLineEnding = lineText.endsWith("  ");
    let blockid = "";
    const match = this.blockRef.exec(lineText);
    if (match && match[2]) {
      lineText = match[1];
      blockid = match[2];
    }
    if (this.initSettings.resetRegExp) {
      lineText = lineText.replace(this.initSettings.resetRegExp, "");
    }
    lineText = lineText.replace(/\s*$/, blockid);
    if (this.settings.appendRemoveAllTasks && mark !== " ") {
      lineText = this.completeTaskLine(lineText, mark);
    }
    if (strictLineEnding) {
      lineText += "  ";
    }
    return lineText;
  }
  resetAllTasks(source) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const lines = source.split("\n");
    const result = [];
    let inCompletedSection = false;
    for (const line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
        }
        result.push(line);
      } else if (line.trim() === LOG_HEADING) {
        inCompletedSection = true;
        result.push(line);
      } else if (this.isCompletedTaskLine(line)) {
        result.push(this.resetTaskLine(line));
      } else {
        result.push(line);
      }
    }
    return result.join("\n");
  }
  moveCompletedTasksInFile(source) {
    const LOG_HEADING = this.settings.completedAreaHeader || "## Log";
    const lines = source.split("\n");
    if (source.indexOf(LOG_HEADING) < 0) {
      if (lines[lines.length - 1].trim() !== "") {
        lines.push("");
      }
      lines.push(LOG_HEADING);
    }
    const remaining = [];
    const completedSection = [];
    const newTasks = [];
    let inCompletedSection = false;
    let inTask = false;
    let inCallout = false;
    let completedItemsIndex = lines.length;
    for (let line of lines) {
      if (inCompletedSection) {
        if (line.startsWith("#") || line.trim() === "---") {
          inCompletedSection = false;
          remaining.push(line);
        } else {
          completedSection.push(line);
        }
      } else if (line.trim() === LOG_HEADING) {
        inCompletedSection = true;
        completedItemsIndex = remaining.push(line);
        remaining.push("%%%COMPLETED_ITEMS_GO_HERE%%%");
      } else {
        if (this.isCompletedTaskLine(line)) {
          if (this.settings.completedAreaRemoveCheckbox) {
            line = this.removeCheckboxFromLine(line);
          }
          inTask = true;
          inCallout = this.isCallout(line);
          newTasks.push(line);
        } else if (inTask && !this.isTaskLine(line) && this.isContinuation(line, inCallout)) {
          newTasks.push(line);
        } else {
          inTask = false;
          inCallout = false;
          remaining.push(line);
        }
      }
    }
    let result = remaining.slice(0, completedItemsIndex).concat(...newTasks).concat(...completedSection);
    if (completedItemsIndex < remaining.length - 1) {
      result = result.concat(remaining.slice(completedItemsIndex + 1));
    }
    return result.join("\n");
  }
  isCompletedTaskLine(lineText) {
    return this.initSettings.completedTaskRegExp.test(lineText);
  }
  isIncompleteTaskLine(lineText) {
    return this.initSettings.incompleteTaskRegExp.test(lineText);
  }
  isTaskLine(lineText) {
    return this.anyTaskMark.test(lineText);
  }
  isContinuation(lineText, inCallout) {
    if (inCallout) {
      const match = this.blockQuote.exec(lineText);
      if (match) {
        return match[1].endsWith(">") || match[1].endsWith("  ") || match[1].endsWith("	");
      }
    }
    return this.continuation.test(lineText);
  }
  isCallout(lineText) {
    return this.blockQuote.test(lineText);
  }
  replaceLiterals(segment) {
    return segment.replace(/\(/g, "\\(").replace(/\)/g, "\\)").replace(/\[/g, "\\[").replace(/\]/g, "\\]");
  }
};

// src/taskcollector-Settings.ts
var DEFAULT_SETTINGS = {
  completedAreaHeader: "## Log",
  removeExpression: "",
  appendDateFormat: "",
  appendRemoveAllTasks: false,
  incompleteTaskValues: " ",
  onlyLowercaseX: false,
  supportCanceledTasks: true,
  previewOnClick: false,
  rightClickComplete: false,
  rightClickMark: false,
  rightClickMove: false,
  rightClickResetTask: false,
  rightClickResetAll: false,
  rightClickToggleAll: false,
  completedAreaRemoveCheckbox: false
};

// src/taskcollector-SettingsTab.ts
var import_obsidian2 = require("obsidian");
var TaskCollectorSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin, taskCollector) {
    super(app, plugin);
    this.plugin = plugin;
    this.taskCollector = taskCollector;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h1", { text: "Task Collector" });
    const tempSettings = Object.assign(
      this.taskCollector.settings
    );
    new import_obsidian2.Setting(this.containerEl).setName("Only support x for completed tasks").setDesc(
      "Only use 'x' (lower case) to indicate completed tasks (hide X (upper case))."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.onlyLowercaseX).onChange((value) => __async(this, null, function* () {
        tempSettings.onlyLowercaseX = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Support canceled tasks").setDesc(
      "Use a - to indicate canceled tasks. Canceled tasks are processed in the same way as completed tasks using options below."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.supportCanceledTasks).onChange((value) => __async(this, null, function* () {
        tempSettings.supportCanceledTasks = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Additional task types").setDesc(
      "Specify the set of single characters that indicate in-progress or incomplete tasks, e.g. 'i> !?D'."
    ).addText(
      (text) => text.setPlaceholder("> !?").setValue(tempSettings.incompleteTaskValues).onChange((value) => __async(this, null, function* () {
        if (value.contains("x")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (x): ${value}`
          );
        } else if (!tempSettings.onlyLowercaseX && value.contains("X")) {
          console.log(
            `Set of characters should not contain the marker for completed tasks (X): ${value}`
          );
        } else if (tempSettings.supportCanceledTasks && value.contains("-")) {
          console.log(
            `Set of characters should not contain the marker for canceled tasks (-): ${value}`
          );
        } else {
          if (!value.contains(" ")) {
            value = " " + value;
          }
          tempSettings.incompleteTaskValues = value;
          this.taskCollector.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        }
      }))
    );
    this.containerEl.createEl("h2", { text: "Completing tasks" });
    this.containerEl.createEl("p", {
      text: "Completed tasks (and optionally '-' for canceled items) gain special treatment based on the settings below."
    });
    new import_obsidian2.Setting(this.containerEl).setName("Append date to completed task").setDesc(
      "If non-empty, append today's date in the given moment.js string format to the end of the task text."
    ).addMomentFormat(
      (momentFormat) => momentFormat.setPlaceholder("YYYY-MM-DD").setValue(tempSettings.appendDateFormat).onChange((value) => __async(this, null, function* () {
        try {
          (0, import_obsidian2.moment)().format(value);
          tempSettings.appendDateFormat = value;
          this.taskCollector.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing specified date format: ${value}`
          );
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Remove text in completed task").setDesc(
      "Text matching this regular expression should be removed from the task text. Be careful! Test your expression first. The global flag, 'g' is used for a per-line match."
    ).addText(
      (text) => text.setPlaceholder(" #(todo|task)").setValue(tempSettings.removeExpression).onChange((value) => __async(this, null, function* () {
        try {
          this.taskCollector.tryCreateRemoveRegex(value);
          tempSettings.removeExpression = value;
          this.taskCollector.updateSettings(tempSettings);
          yield this.plugin.saveSettings();
        } catch (e) {
          console.log(
            `Error parsing regular expression for text replacement: ${value}`
          );
        }
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Apply these settings to all tasks").setDesc(
      "Append and remove text as configured above when marking tasks with anything other than a space (to reset)."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.appendRemoveAllTasks).onChange((value) => __async(this, null, function* () {
        tempSettings.appendRemoveAllTasks = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    this.containerEl.createEl("h2", { text: "Moving completed tasks" });
    new import_obsidian2.Setting(this.containerEl).setName("Completed area header").setDesc(
      `Completed (or canceled) items will be inserted under the specified header (most recent at the top). When scanning the document for completed/canceled tasks, the contents from this configured header to the next heading or separator (---) will be ignored. This heading will be created if the command is invoked and the heading does not exist. The default heading is '${DEFAULT_SETTINGS.completedAreaHeader}'.`
    ).addText(
      (text) => text.setPlaceholder("## Log").setValue(tempSettings.completedAreaHeader).onChange((value) => __async(this, null, function* () {
        tempSettings.completedAreaHeader = value.trim();
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Remove the checkbox from moved items").setDesc(
      `Remove the checkbox from completed (or canceled) tasks during the move to the completed area. This transforms tasks into normal list items. Task Collector will not be able to reset these items. They also will not appear in task searches or queries. The default value is: '${DEFAULT_SETTINGS.completedAreaRemoveCheckbox}'.`
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.completedAreaRemoveCheckbox).onChange((value) => __async(this, null, function* () {
        tempSettings.completedAreaRemoveCheckbox = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    this.containerEl.createEl("h2", {
      text: "Marking items using menus"
    });
    this.containerEl.createEl("p", {
      text: "Task Collector creates commands that can be bound to hotkeys or accessed using slash commands for marking tasks complete (or canceled) and resetting tasks to an incomplete state. The following settings add right click context menu items for those commands."
    });
    new import_obsidian2.Setting(this.containerEl).setName(
      "Preview / Live preview: Show the selection menu when a checkbox is clicked"
    ).setDesc(
      "Display a panel that allows you to select (with mouse or keyboard) the value to assign when you click the task. The selected value will determine follow-on actions: complete, cancel, or reset."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.previewOnClick).onChange((value) => __async(this, null, function* () {
        tempSettings.previewOnClick = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for marking a task").setDesc(
      "Add an item to the right-click menu in edit mode to mark the task on the current line (or within the current selection). This menu item will trigger a quick pop-up modal to select the desired mark value. The selected value will determine follow-on actions: complete, cancel, or reset."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickMark).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickMark = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for completing a task").setDesc(
      "Add an item to the right-click menu in edit mode to mark the task on the current line (or within the current selection) complete. If canceled items are supported, an additional menu item will be added to mark selected tasks as canceled."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickComplete).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickComplete = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for resetting a task").setDesc(
      "Add an item to the right-click menu in edit mode to reset the task on the current line (or within the current selection)."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickResetTask).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickResetTask = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu items for completing all tasks").setDesc(
      "Add an item to the right-click menu in edit mode to mark all incomplete tasks in the current document complete."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickToggleAll).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickToggleAll = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for resetting all tasks").setDesc(
      "Add an item to the right-click menu to reset all completed (or canceled) tasks."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickResetAll).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickResetAll = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
    new import_obsidian2.Setting(this.containerEl).setName("Add menu item for moving all completed tasks").setDesc(
      "Add an item to the right-click menu to move all completed (or canceled) tasks."
    ).addToggle(
      (toggle) => toggle.setValue(tempSettings.rightClickMove).onChange((value) => __async(this, null, function* () {
        tempSettings.rightClickMove = value;
        this.taskCollector.updateSettings(tempSettings);
        yield this.plugin.saveSettings();
      }))
    );
  }
};

// src/taskcollector-TaskMarkModal.ts
var import_obsidian3 = require("obsidian");
function promptForMark(app, taskCollector) {
  return new Promise((resolve) => {
    const modal = new TaskMarkModal(app, taskCollector);
    modal.onClose = () => {
      resolve(modal.chosenMark);
    };
    modal.open();
  });
}
var TaskMarkModal = class extends import_obsidian3.Modal {
  constructor(app, taskCollector) {
    super(app);
    this.taskCollector = taskCollector;
    this.containerEl.id = "taskcollector-modal";
  }
  onOpen() {
    const selector = this.contentEl.createDiv(
      "taskcollector-selector markdown-preview-view"
    );
    const completedList = selector.createEl("ul");
    completedList.addClass("contains-task-list");
    this.addTaskValues(
      completedList,
      this.taskCollector.initSettings.completedTasks,
      true
    );
    const list = selector.createEl("ul");
    list.addClass("contains-task-list");
    this.addTaskValues(
      list,
      this.taskCollector.settings.incompleteTaskValues,
      false
    );
    const footer = selector.createEl("nav");
    const esc = footer.createSpan();
    esc.innerHTML = "<b>esc</b> to dismiss";
    const bksp = footer.createSpan();
    bksp.innerHTML = "<b>bksp</b> to remove <code>[]</code>";
    const self = this;
    const keyListener = function(event) {
      self.chosenMark = event.key;
      event.preventDefault();
      event.stopImmediatePropagation();
      self.close();
    };
    this.scope.register([], null, keyListener);
    this.scope.register(["Shift"], null, keyListener);
  }
  addTaskValues(list, choices, markComplete) {
    const self = this;
    for (const character of choices) {
      const li = list.createEl("li", {
        cls: "task-list-item " + (character == " " ? "" : " is-checked"),
        attr: {
          "data-task": character
        }
      });
      li.addEventListener("click", function(event) {
        self.chosenMark = character;
        self.close();
      });
      const input = li.createEl("input", {
        cls: "task-list-item-checkbox",
        attr: {
          id: "task-list-item-checkbox-" + character,
          type: "checkbox",
          style: "pointer-events: none;"
        }
      });
      if (character != " ") {
        input.setAttribute("checked", "");
      }
      li.createEl("span", {
        text: character == " " ? "\u2423" : character,
        attr: {
          style: "pointer-events: none;"
        }
      });
    }
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/taskcollector-Api.ts
var TaskCollectorApi = class {
  constructor(app, taskCollector) {
    this.app = app;
    this.taskCollector = taskCollector;
  }
  getCompletedTaskValues() {
    return this.taskCollector.initSettings.completedTasks;
  }
  getIncompleteTaskValues() {
    return this.taskCollector.settings.incompleteTaskValues;
  }
  getMark() {
    return promptForMark(this.app, this.taskCollector);
  }
  isComplete(value) {
    return this.getCompletedTaskValues().contains(value);
  }
  isCanceled(value) {
    return value === "-";
  }
};

// src/taskcollector-Plugin.ts
var TaskCollectorPlugin = class extends import_obsidian4.Plugin {
  constructor() {
    super(...arguments);
    this.handlersRegistered = false;
  }
  onload() {
    return __async(this, null, function* () {
      console.log("loading Task Collector (TC)");
      this.taskCollector = new TaskCollector(this.app);
      this.addSettingTab(
        new TaskCollectorSettingsTab(this.app, this, this.taskCollector)
      );
      yield this.loadSettings();
      (0, import_obsidian4.addIcon)(
        "tc-complete-item" /* COMPLETE */,
        '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-check-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm10.03 4.97a.75.75 0 0 1 .011 1.05l-3.992 4.99a.75.75 0 0 1-1.08.02L4.324 8.384a.75.75 0 1 1 1.06-1.06l2.094 2.093 3.473-4.425a.75.75 0 0 1 1.08-.022z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-cancel-item" /* CANCEL */,
        '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-dash-square-fill" viewBox="0 0 16 16">  <path d="M2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2zm2.5 7.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-reset-item" /* RESET */,
        '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-square-fill" viewBox="0 0 16 16"><path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-mark-item" /* MARK */,
        '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path transform="scale(.16)" d="m12.5 0a12.5 12.5 0 00-12.5 12.5v75a12.5 12.5 0 0012.5 12.5h75a12.5 12.5 0 0012.5-12.5v-75a12.5 12.5 0 00-12.5-12.5h-75zm38.146 21.135 8.7324 19.098 20.684 3.6328-15.465 14.207 2.9355 20.793-18.289-10.316-18.869 9.2188 4.1602-20.584-14.598-15.098 20.861-2.4043 9.8477-18.547z" stroke-width="6.25"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-complete-all-items" /* COMPLETE_ALL */,
        '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/><g transform="translate(.49737 -.0026315)" fill="currentColor"><path d="m3.6171 13.149a.5.5 0 01-.708 0l-1-1a.50063.50063 0 01.708-.708l.646.647 1.646-1.647a.50063.50063 0 01.708.708z"/><path d="m3.6171 5.6181a.5.5 0 01-.708 0l-1-1a.50063.50063 0 11.708-.708l.646.647 1.646-1.647a.50063.50063 0 11.708.708z"/></g></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-clear-all-items" /* CLEAR */,
        '<svg class="bi bi-square-fill" fill="currentColor" version="1.1" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="m2 0a2 2 0 00-2 2v12a2 2 0 002 2h12a2 2 0 002-2v-12a2 2 0 00-2-2h-12zm1.5098 2.041h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.3945 1.2207h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5zm-4.4023 6.2656h1.5a1.5 1.5 0 011.5 1.5v1.5a1.5 1.5 0 01-1.5 1.5h-1.5a1.5 1.5 0 01-1.5-1.5v-1.5a1.5 1.5 0 011.5-1.5zm4.4023 1.2656h5.6895a.40645.5 0 01.40625.5v1a.40645.5 0 01-.40625.5h-5.6895a.40645.5 0 01-.40625-.5v-1a.40645.5 0 01.40625-.5z"/></svg>'
      );
      (0, import_obsidian4.addIcon)(
        "tc-move-all-checked-items" /* MOVE */,
        '<svg xmlns="http://www.w3.org/2000/svg" fill="currentColor" class="bi bi-save-fill" viewBox="0 0 16 16">  <path d="M8.5 1.5A1.5 1.5 0 0 1 10 0h4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h6c-.314.418-.5.937-.5 1.5v7.793L4.854 6.646a.5.5 0 1 0-.708.708l3.5 3.5a.5.5 0 0 0 .708 0l3.5-3.5a.5.5 0 0 0-.708-.708L8.5 9.293V1.5z"/></svg>'
      );
      const completeTaskCommand = {
        id: "task-collector-mark-done",
        name: "Complete item",
        icon: "tc-complete-item" /* COMPLETE */,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(
            "x",
            this.getCurrentLinesFromEditor(editor)
          );
        }
      };
      const cancelTaskCommand = {
        id: "task-collector-mark-canceled",
        name: "Cancel item",
        icon: "tc-cancel-item" /* CANCEL */,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(
            "-",
            this.getCurrentLinesFromEditor(editor)
          );
        }
      };
      const resetTaskCommand = {
        id: "task-collector-mark-reset",
        name: "Reset item",
        icon: "tc-reset-item" /* RESET */,
        editorCallback: (editor, view) => {
          this.markTaskOnLines(
            " ",
            this.getCurrentLinesFromEditor(editor)
          );
        }
      };
      const markTaskCommand = {
        id: "task-collector-mark",
        name: "Mark item",
        icon: "tc-mark-item" /* MARK */,
        editorCallback: (editor, view) => __async(this, null, function* () {
          const mark = yield promptForMark(this.app, this.taskCollector);
          if (mark) {
            this.markTaskOnLines(
              mark,
              this.getCurrentLinesFromEditor(editor)
            );
          }
        })
      };
      const completeAllTasksCommand = {
        id: "task-collector-mark-all-done",
        name: "Complete all tasks",
        icon: "tc-complete-all-items" /* COMPLETE_ALL */,
        callback: () => __async(this, null, function* () {
          this.completeAllTasks();
        })
      };
      const clearAllTasksCommand = {
        id: "task-collector-clear-all-items",
        name: "Reset all completed tasks",
        icon: "tc-clear-all-items" /* CLEAR */,
        callback: () => __async(this, null, function* () {
          this.resetAllTasks();
        })
      };
      const moveTaskCommand = {
        id: "task-collector-move-completed-tasks",
        name: "Move all completed tasks to configured heading",
        icon: "tc-move-all-checked-items" /* MOVE */,
        callback: () => __async(this, null, function* () {
          this.moveAllTasks();
        })
      };
      this.addCommand(completeTaskCommand);
      if (this.taskCollector.settings.supportCanceledTasks) {
        this.addCommand(cancelTaskCommand);
      }
      this.addCommand(markTaskCommand);
      this.addCommand(resetTaskCommand);
      this.addCommand(moveTaskCommand);
      this.addCommand(completeAllTasksCommand);
      this.addCommand(clearAllTasksCommand);
      this.registerHandlers();
      this.api = new TaskCollectorApi(this.app, this.taskCollector);
    });
  }
  getCurrentLinesFromEditor(editor) {
    const lines = [];
    if (editor.somethingSelected()) {
      const cursorStart = editor.getCursor("from");
      const cursorEnd = editor.getCursor("to");
      for (let i = cursorStart.line; i <= cursorEnd.line; i++) {
        lines.push(i);
      }
    } else {
      const anchor = editor.getCursor("from");
      lines.push(anchor.line);
    }
    return lines;
  }
  buildMenu(menu, lines) {
    if (this.taskCollector.settings.rightClickMark) {
      menu.addItem(
        (item) => item.setTitle("(TC) Mark Task").setIcon("tc-mark-item" /* MARK */).onClick(() => __async(this, null, function* () {
          const mark = yield promptForMark(
            this.app,
            this.taskCollector
          );
          if (mark) {
            this.markTaskOnLines(mark, lines);
          }
        }))
      );
    }
    if (this.taskCollector.settings.rightClickComplete) {
      menu.addItem(
        (item) => item.setTitle("(TC) Complete Task").setIcon("tc-complete-item" /* COMPLETE */).onClick(() => {
          this.markTaskOnLines("x", lines);
        })
      );
      if (this.taskCollector.settings.supportCanceledTasks) {
        menu.addItem(
          (item) => item.setTitle("(TC) Cancel Task").setIcon("tc-cancel-item" /* CANCEL */).onClick(() => {
            this.markTaskOnLines("-", lines);
          })
        );
      }
    }
    if (this.taskCollector.settings.rightClickResetTask) {
      menu.addItem(
        (item) => item.setTitle("(TC) Reset Task").setIcon("tc-reset-item" /* RESET */).onClick(() => {
          this.markTaskOnLines(" ", lines);
        })
      );
    }
    if (this.taskCollector.settings.rightClickMove) {
      menu.addItem(
        (item) => item.setTitle("(TC) Move completed tasks").setIcon("tc-move-all-checked-items" /* MOVE */).onClick(() => __async(this, null, function* () {
          this.moveAllTasks();
        }))
      );
    }
    if (this.taskCollector.settings.rightClickToggleAll) {
      menu.addItem(
        (item) => item.setTitle("(TC) Complete All Tasks").setIcon("tc-complete-all-items" /* COMPLETE_ALL */).onClick(() => __async(this, null, function* () {
          this.completeAllTasks();
        }))
      );
    }
    if (this.taskCollector.settings.rightClickResetAll) {
      menu.addItem(
        (item) => item.setTitle("(TC) Reset All Tasks").setIcon("tc-clear-all-items" /* CLEAR */).onClick(() => __async(this, null, function* () {
          this.resetAllTasks();
        }))
      );
    }
  }
  markTaskOnLines(mark, lines) {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.markTaskInSource(source, mark, lines);
      this.app.vault.modify(activeFile, result);
    });
  }
  moveAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.moveCompletedTasksInFile(source);
      this.app.vault.modify(activeFile, result);
    });
  }
  completeAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.markAllTasksComplete(source, "x");
      this.app.vault.modify(activeFile, result);
    });
  }
  resetAllTasks() {
    return __async(this, null, function* () {
      const activeFile = this.app.workspace.getActiveFile();
      const source = yield this.app.vault.read(activeFile);
      const result = this.taskCollector.resetAllTasks(source);
      this.app.vault.modify(activeFile, result);
    });
  }
  registerHandlers() {
    if (this.taskCollector.initSettings.registerHandlers && !this.handlersRegistered) {
      this.handlersRegistered = true;
      if (this.taskCollector.initSettings.rightClickTaskMenu) {
        this.registerEvent(
          this.eventRef = this.app.workspace.on(
            "editor-menu",
            (menu, editor) => {
              this.buildMenu(
                menu,
                this.getCurrentLinesFromEditor(editor)
              );
            }
          )
        );
      }
      this.registerMarkdownPostProcessor(
        this.postProcessor = (el, ctx) => {
          const checkboxes = el.querySelectorAll(
            ".task-list-item-checkbox"
          );
          if (!checkboxes.length)
            return;
          const section = ctx.getSectionInfo(el);
          if (!section)
            return;
          const { lineStart } = section;
          for (const checkbox of Array.from(checkboxes)) {
            const line = Number(checkbox.dataset.line);
            if (this.taskCollector.initSettings.rightClickTaskMenu) {
              this.registerDomEvent(
                checkbox.parentElement,
                "contextmenu",
                (ev) => {
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  const view = this.app.workspace.getActiveViewOfType(
                    import_obsidian4.MarkdownView
                  );
                  if (view && view.editor) {
                    const menu = new import_obsidian4.Menu(this.app);
                    this.buildMenu(menu, [
                      lineStart + line
                    ]);
                    menu.showAtMouseEvent(ev);
                  }
                }
              );
            }
            if (this.taskCollector.settings.previewOnClick) {
              this.registerDomEvent(
                checkbox,
                "click",
                (ev) => __async(this, null, function* () {
                  ev.stopImmediatePropagation();
                  ev.preventDefault();
                  const mark = yield promptForMark(
                    this.app,
                    this.taskCollector
                  );
                  if (mark) {
                    this.markTaskOnLines(mark, [
                      lineStart + line
                    ]);
                  }
                })
              );
            }
          }
        }
      );
    }
  }
  unregisterHandlers() {
    this.handlersRegistered = false;
    if (this.eventRef) {
      this.app.workspace.offref(this.eventRef);
      this.eventRef = null;
    }
    if (this.postProcessor) {
      import_obsidian4.MarkdownPreviewRenderer.unregisterPostProcessor(this.postProcessor);
      this.postProcessor = null;
    }
  }
  onunload() {
    console.log("unloading Task Collector");
  }
  loadSettings() {
    return __async(this, null, function* () {
      const settings = Object.assign(
        {},
        DEFAULT_SETTINGS,
        yield this.loadData()
      );
      if (settings.rightClickReset) {
        delete settings.rightClickReset;
        yield this.saveData(settings);
      }
      this.taskCollector.updateSettings(settings);
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.taskCollector.settings);
      if (this.taskCollector.initSettings.rightClickTaskMenu && !this.handlersRegistered) {
        this.registerHandlers();
      }
      if (!this.taskCollector.initSettings.rightClickTaskMenu && this.handlersRegistered) {
        this.unregisterHandlers();
      }
    });
  }
};

// src/main.ts
var main_default = TaskCollectorPlugin;
